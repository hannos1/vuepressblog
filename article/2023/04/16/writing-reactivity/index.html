<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue3的响应式原理学习 | Blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/vuepressblog/logo.png">
    <meta name="description" content="
最近学习了一下大圣老师的vue3源码讲解，感觉收获非常多，于是现在来分享下我最近的学习成果。这里是原文地址，感兴趣的话可以从里面找到一个迷你vue框架。
reactive的原理
首先请看一张图片
&lt;img :src=&quot;$withBase(&#39;/asset/vu ...">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/vuepressblog/assets/css/0.styles.e6a5e1c7.css" as="style"><link rel="preload" href="/vuepressblog/assets/js/app.7b4fa253.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/6.966b288f.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/3.bad93855.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/17.98c2b00f.js" as="script"><link rel="prefetch" href="/vuepressblog/assets/js/10.800ce87b.js"><link rel="prefetch" href="/vuepressblog/assets/js/11.e2cbdcf3.js"><link rel="prefetch" href="/vuepressblog/assets/js/12.bf63a920.js"><link rel="prefetch" href="/vuepressblog/assets/js/13.e164c151.js"><link rel="prefetch" href="/vuepressblog/assets/js/14.d69930bc.js"><link rel="prefetch" href="/vuepressblog/assets/js/15.11c67c2f.js"><link rel="prefetch" href="/vuepressblog/assets/js/16.e7a2ed08.js"><link rel="prefetch" href="/vuepressblog/assets/js/4.e63ab3aa.js"><link rel="prefetch" href="/vuepressblog/assets/js/5.74f1fcd7.js"><link rel="prefetch" href="/vuepressblog/assets/js/7.4e7b2103.js"><link rel="prefetch" href="/vuepressblog/assets/js/8.8065168e.js"><link rel="prefetch" href="/vuepressblog/assets/js/9.a4732338.js"><link rel="prefetch" href="/vuepressblog/assets/js/vuejs-paginate.55b38529.js">
    <link rel="stylesheet" href="/vuepressblog/assets/css/0.styles.e6a5e1c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/vuepressblog/" class="nav-link home-link">Blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/vuepressblog/" class="nav-link">主页</a></li><li class="nav-item"><a href="/vuepressblog/article/" class="nav-link router-link-active">文章</a></li><li class="nav-item"><a href="https://github.com/hannos1" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/vuepressblog/" class="nav-link mobile-home-link">Blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/vuepressblog/" class="nav-link">主页</a></li><li class="mobile-nav-item"><a href="/vuepressblog/article/" class="nav-link router-link-active">文章</a></li><li class="mobile-nav-item"><a href="https://github.com/hannos1" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        vue3的响应式原理学习
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">hannos1</span> <span itemprop="address">   in China</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2023-04-16T00:00:00.000Z">
      Sun Apr 16 2023
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/vuepressblog/tag/JavaScript" data-v-42ccfcd5><span data-v-42ccfcd5>JavaScript</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/vuepressblog/tag/Vue3" data-v-42ccfcd5><span data-v-42ccfcd5>Vue3</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/vuepressblog/tag/effect" data-v-42ccfcd5><span data-v-42ccfcd5>effect</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/vuepressblog/tag/reactive" data-v-42ccfcd5><span data-v-42ccfcd5>reactive</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>最近学习了一下大圣老师的vue3源码讲解，感觉收获非常多，于是现在来分享下我最近的学习成果。这里是<a href="https://time.geekbang.org/column/article/470089" target="_blank" rel="noopener noreferrer">原文地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，感兴趣的话可以从里面找到一个迷你vue框架。<br></p> <h2 id="reactive的原理"><a href="#reactive的原理" class="header-anchor">#</a> reactive的原理</h2> <p><strong>首先请看一张图片</strong> <img src="/vuepressblog/asset/vueactive.png" alt="vue响应式原理.png">
从这张图片中我们可以看到一个<code>reactive</code>对象从定义到响应的过程，如果您第一次学习vue源码，您可能会觉得一头雾水。这里我尽量用简单的文字来描述这个过程，这个过程大概是这样的：</p> <ul><li><p>对象<code>{num:1,num2:2}</code>经过reactive()声明后被<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer"><code>Proxy</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>包裹</p></li> <li><p>然后在<code>effect</code>函数中，触发上文Proxy的<strong>get</strong>回调函数。get函数体中会调用<code>track</code>函数来收集依赖</p></li> <li><p>由于计时器每秒修改一次counter.num1，会触发Proxy的<strong>set</strong>回调函数，set函数体中的<code>trigger</code>函数会把counter.num1 + counter.num2重新赋值给<code>dummy</code></p></li></ul> <p>现在我们知道了要声明一个reactive对象我们需要一个<code>reactive()</code>函数和<code>effect()</code>函数，我们来看他们具体做什么。</p> <h3 id="reactive函数"><a href="#reactive函数" class="header-anchor">#</a> reactive函数</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// reactive.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> mutableHandlers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./baseHandlers'</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> reactiveMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 缓存map 性能优化 组件卸载 WeakMap会自动删除 弱引用</span>
<span class="token comment">// vue中的依赖关系是用&quot;对象&quot;来组织的 key为对象此时用map收集更适合</span>
    
<span class="token keyword">export</span> <span class="token keyword">const</span> ReactiveFlags <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token constant">RAW</span><span class="token operator">:</span><span class="token string">&quot;__v_raw&quot;</span><span class="token punctuation">,</span>
    <span class="token constant">IS_REACTIVE</span><span class="token operator">:</span><span class="token string">&quot;__V_isReactive&quot;</span> <span class="token comment">// reactive对象的标签</span>
<span class="token punctuation">}</span>

<span class="token comment">// 深度代理</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>reactiveMap<span class="token punctuation">,</span>mutableHandlers<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>proxyMap<span class="token punctuation">,</span>proxyHandlers</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 2.</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">reactive </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 必须是一个对象</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> target
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 通过proxy创建代理  map里不同的对象存储不同类型的reactive依赖关系</span>
    <span class="token keyword">const</span> existingProxy <span class="token operator">=</span> proxyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>existingProxy<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> existingProxy
    <span class="token punctuation">}</span>
    
    <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>proxyHandlers<span class="token punctuation">)</span>  
    proxyMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>proxy<span class="token punctuation">)</span>  <span class="token comment">// 缓存</span>
    
    <span class="token keyword">return</span> proxy
<span class="token punctuation">}</span>
</code></pre></div><p>没错，<code>reactive()</code>函数只是将<code>{num1:1,num2:2}</code>封装成了响应式对象<code>Proxy</code>并且将它返回给<code>counter</code>，其他啥也没干。</p> <p>如果去掉上面代码的优化部分，你会看到：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// reactive.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> mutableHandlers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./baseHandlers'</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>mutableHandlers<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的proxy对象依赖<code>mutableHandlers</code>来检测数据，以下是baseHandlers.js的内容：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// baseHandlers.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> track<span class="token punctuation">,</span> trigger <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./effect'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./reactive'</span>

<span class="token keyword">const</span> get <span class="token operator">=</span> <span class="token function">createGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token function">createSetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">createSetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>receiver</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>receiver<span class="token punctuation">)</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span><span class="token string">'set'</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token comment">// 把依赖函数依次触发，依赖就是dummy和num1的关系</span>
        <span class="token keyword">return</span> result
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createGetter</span><span class="token punctuation">(</span><span class="token parameter">shallow <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>receiver</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>receiver<span class="token punctuation">)</span> <span class="token comment">// 找到target[key]</span>
        <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token comment">// 收集依赖</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> shallow <span class="token operator">?</span> res <span class="token operator">:</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// 这里如果发现属性num1也是对象，就要深度代理 让num1的属性也被proxy监听</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res <span class="token comment">// 返回原本的值，这里返回num1的值</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> val <span class="token operator">!==</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> mutableHandlers <span class="token operator">=</span> <span class="token punctuation">{</span>
    get<span class="token punctuation">,</span>
    set
<span class="token punctuation">}</span> <span class="token comment">// proxy除了get和set还有其他的钩子，可以到mdn查阅 </span>
</code></pre></div><p>注意一下createGetter中的细节，如果num1也是对象，那么它也应该被Proxy代理实现深度代理，如果设置了shallow属性就不继续代理了。</p> <p>这样我们就拥有了一个<code>Proxy</code>对象，它在我们<strong>读取</strong>该对象的属性值的时候会触发<code>get</code>把需要的值返回，在<strong>修改</strong>该对象的属性值的时候会触发<code>set</code>把属性值修改。</p> <p>一旦<strong>读取</strong>这个对象的属性值，我们假设是num1，我们就利用get把这次触发读取的<strong>依赖关系</strong>(dummy = num1 + num2)记录起来，这就是<code>track</code>函数。</p> <p>而一旦<strong>修改</strong>这个对象的属性值，同样假设是num1，我们就利用set把修改后的值重新交给那个跟num1有关系的变量(上文dummy)，这就是<code>trigger</code>函数。</p> <p>而所有的变量都得到了它们此刻正确的值后，vue框架会重新渲染模板让页面发生改变，这就是响应式的基本原理。</p> <p>那么track和trigger具体咋实现的呢？接下来请看<code>effect</code>函数。</p> <h3 id="effect函数"><a href="#effect函数" class="header-anchor">#</a> effect函数</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// effect.js</span>
<span class="token keyword">let</span> activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">const</span> targetMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// targetMap依赖图谱，为了依赖函数的查找，o(1)时间复杂度，单例模式好管理可以全局访问</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// fn就是回调函数 options: lazy schedular</span>
    <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token comment">// 容错 finally用于清除掉activeEffect的缓存</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            activeEffect <span class="token operator">=</span> effectFn <span class="token comment">// 缓存，给下面的track提供依赖函数fn 同时effect会先执行fn</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
            activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 暂时不实现lazy</span>
        <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 触发proxy get</span>
    <span class="token punctuation">}</span>
    effectFn<span class="token punctuation">.</span>scheduler <span class="token operator">=</span> options<span class="token punctuation">.</span>scheduler
    <span class="token keyword">return</span> effectFn <span class="token comment">// 返回的函数不会被立即执行 可以返回到外面再用队列管理</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>type<span class="token punctuation">,</span>key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> depsMap <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>  <span class="token comment">// 第一层查找对象  reactive({num1:1,num2:2})</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 如果依赖图谱里没有就加进去 否则不加</span>
        depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
        targetMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>depsMap<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// 同一个num1可能会触发多次get,性能优化</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span><span class="token punctuation">{</span>
        deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// effect 去重</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> activeEffect<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 如果effect数组(集合)里没有就加进去</span>
        deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>deps<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>type<span class="token punctuation">,</span>key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> depsMap <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>  <span class="token comment">// 第一层</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 如果图谱里没有(可能被垃圾回收了,weekmap)</span>
        <span class="token keyword">return</span> 
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>  <span class="token comment">// 第二层</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 如果图谱里面的是空对象{},没有属性值</span>
        <span class="token keyword">return</span> 
    <span class="token punctuation">}</span>
    deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token comment">// 挨个执行</span>
        <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到effect函数其实也没干啥活，就是把传入的fn即<code>() =&gt; { dummy = counter.num1 + counter.num2 }</code>放到一个变量<code>activeEffect</code>中缓存了，然后把fn执行了一下。</p> <p>而在执行fn的时候，由于此时的counter是一个Proxy对象，读值会触发<code>get</code>，把缓存了fn的activeEffect交给<code>track</code>让它保存到依赖图谱<code>targetMap</code>中。</p> <p>而当我们改变counter的某个属性值时，修改值会触发<code>set</code>,此时<code>trigger</code>函数被调用，它会通过参数在targetMap中找到被修改的值存着的函数(就是上文中的activeEffect), 并且挨个执行，这样就把一开始的<code>() =&gt; { dummy = counter.num1 + counter.num2 }</code>执行了一下，执行前num1的值已经发生修改了，这样dummy也会跟着修改。</p> <p>现在再回去看流程图是不是就更加清晰了？<br></p> <h2 id="ref的原理"><a href="#ref的原理" class="header-anchor">#</a> ref的原理</h2> <p>了解了reactive的原理，再来看ref是如何实现的。</p> <p>上文中我们其实已经对响应式的实现已经有了一定的了解，就是把原有对象进行数据代理，然后利用get收集依赖，利用set执行依赖嘛。如果你理解了这些，那么相信此时你一定能写出一个使用Proxy实现的<code>ref()</code>。</p> <p>但是实际上使用Proxy来实现ref有点没必要，因为ref只是把<strong>基本数据类型</strong>处理成响应式对象，而复杂数据类型我们可以完全交给reactive来做。即使你给ref传入一个对象，我们同样把它交给reactive。</p> <p>那么对基本数据类型进行数据代理就没有必要使用Proxy了，用不上它的深度代理，为了优化性能我们可以用别的方式来进行数据代理。于是就有了：</p> <h3 id="ref函数"><a href="#ref函数" class="header-anchor">#</a> ref函数</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>track<span class="token punctuation">,</span>trigger<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./effect'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>reactive<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./reactive'</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isRef</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;&amp;</span> val<span class="token punctuation">.</span>__isRef<span class="token punctuation">)</span> 
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isRef</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> val <span class="token comment">// val = ref(ref()) 会走这个分支</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RefImpl</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment">// 简单数据类型的ref</span>
<span class="token punctuation">}</span>

<span class="token comment">// es6 class提供了get set方法</span>
<span class="token keyword">class</span> <span class="token class-name">RefImpl</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>__isRef <span class="token operator">=</span> <span class="token boolean">true</span>  <span class="token comment">// 给响应对象打标签，表示是一个ref对象</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_val <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment">// 返回响应式对象或者基本类型的值</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">track</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'value'</span><span class="token punctuation">)</span> <span class="token comment">// 依赖收集</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_val
    <span class="token punctuation">}</span>
    <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_val<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 如果值没有变化的话不需要响应</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_val <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
            <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'set'</span><span class="token punctuation">,</span><span class="token string">'value'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">isObject</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">reactive</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">:</span> val
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> val <span class="token operator">!==</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><br> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>在vue源码的学习过程中，可以发现响应式的原理似乎并不复杂，对数据进行监听然后在一定时机修改数据并且重新渲染页面就能达到这样的效果。此外其中对代码结构和性能的优化也非常值得学习，比如使用weekMap来缓存和形成依赖图谱，利用变量缓存来减少大量依赖的缓存和数据代理，使用class来优化proxy的使用等等，而据我了解vue对性能的优化并不只如此。如果有兴趣可以了解下<strong>diff算法</strong>和<strong>虚拟DOM</strong>，学习这些相信您会对vue有更加深刻的认识。</p> <p>本文主要用于分享学习成果和思想，抛砖引玉抛砖引玉，如有错误欢迎指正。</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#前言" title="前言">前言</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#reactive的原理" title="reactive的原理">reactive的原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#reactive函数" title="reactive函数">reactive函数</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#effect函数" title="effect函数">effect函数</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#ref的原理" title="ref的原理">ref的原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#ref函数" title="ref函数">ref函数</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#小结" title="小结">小结</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/hannos1" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/vuepressblog/assets/js/app.7b4fa253.js" defer></script><script src="/vuepressblog/assets/js/6.966b288f.js" defer></script><script src="/vuepressblog/assets/js/3.bad93855.js" defer></script><script src="/vuepressblog/assets/js/17.98c2b00f.js" defer></script>
  </body>
</html>
